<!DOCTYPE html>
<html>
<head>
  <title>Blake3 Browser Benchmark</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #e0e0e0; }
    pre { background: #2a2a2a; padding: 15px; border-radius: 5px; overflow-x: auto; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; margin: 5px; }
    .pass { color: #4caf50; }
    .fail { color: #f44336; }
    h2 { color: #90caf9; }
  </style>
</head>
<body>
  <h1>Blake3 Browser Benchmark</h1>
  <p>Tests Pure JS vs WASM SIMD vs Web Workers</p>

  <button onclick="runBenchmark()">Run Benchmark</button>
  <button onclick="runTests()">Run Correctness Tests</button>

  <pre id="output">Click a button to start...</pre>

<script type="module">
// Inline the implementations for browser testing

const IV = new Uint32Array([
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);

const BLOCK_LEN = 64;
const CHUNK_LEN = 1024;
const CHUNK_START = 1;
const CHUNK_END = 2;
const PARENT = 4;
const ROOT = 8;

const IS_LITTLE_ENDIAN = new Uint8Array(new Uint32Array([1]).buffer)[0] === 1;
const blockWordsBuffer = new Uint32Array(16);

function compress(cv, m, counter, blockLen, flags) {
  let s_0 = cv[0] | 0, s_1 = cv[1] | 0, s_2 = cv[2] | 0, s_3 = cv[3] | 0;
  let s_4 = cv[4] | 0, s_5 = cv[5] | 0, s_6 = cv[6] | 0, s_7 = cv[7] | 0;
  let s_8 = 0x6a09e667, s_9 = 0xbb67ae85, s_10 = 0x3c6ef372, s_11 = 0xa54ff53a;
  let s_12 = counter | 0, s_13 = (counter / 0x100000000) | 0, s_14 = blockLen | 0, s_15 = flags | 0;

  let m_0 = m[0] | 0, m_1 = m[1] | 0, m_2 = m[2] | 0, m_3 = m[3] | 0;
  let m_4 = m[4] | 0, m_5 = m[5] | 0, m_6 = m[6] | 0, m_7 = m[7] | 0;
  let m_8 = m[8] | 0, m_9 = m[9] | 0, m_10 = m[10] | 0, m_11 = m[11] | 0;
  let m_12 = m[12] | 0, m_13 = m[13] | 0, m_14 = m[14] | 0, m_15 = m[15] | 0;

  for (let i = 0; i < 7; ++i) {
    s_0 = (((s_0 + s_4) | 0) + m_0) | 0; s_12 ^= s_0; s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_8 = (s_8 + s_12) | 0; s_4 ^= s_8; s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_0 = (((s_0 + s_4) | 0) + m_1) | 0; s_12 ^= s_0; s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_8 = (s_8 + s_12) | 0; s_4 ^= s_8; s_4 = (s_4 >>> 7) | (s_4 << 25);
    s_1 = (((s_1 + s_5) | 0) + m_2) | 0; s_13 ^= s_1; s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_9 = (s_9 + s_13) | 0; s_5 ^= s_9; s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_1 = (((s_1 + s_5) | 0) + m_3) | 0; s_13 ^= s_1; s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_9 = (s_9 + s_13) | 0; s_5 ^= s_9; s_5 = (s_5 >>> 7) | (s_5 << 25);
    s_2 = (((s_2 + s_6) | 0) + m_4) | 0; s_14 ^= s_2; s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_10 = (s_10 + s_14) | 0; s_6 ^= s_10; s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_2 = (((s_2 + s_6) | 0) + m_5) | 0; s_14 ^= s_2; s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_10 = (s_10 + s_14) | 0; s_6 ^= s_10; s_6 = (s_6 >>> 7) | (s_6 << 25);
    s_3 = (((s_3 + s_7) | 0) + m_6) | 0; s_15 ^= s_3; s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_11 = (s_11 + s_15) | 0; s_7 ^= s_11; s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_3 = (((s_3 + s_7) | 0) + m_7) | 0; s_15 ^= s_3; s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_11 = (s_11 + s_15) | 0; s_7 ^= s_11; s_7 = (s_7 >>> 7) | (s_7 << 25);
    s_0 = (((s_0 + s_5) | 0) + m_8) | 0; s_15 ^= s_0; s_15 = (s_15 >>> 16) | (s_15 << 16);
    s_10 = (s_10 + s_15) | 0; s_5 ^= s_10; s_5 = (s_5 >>> 12) | (s_5 << 20);
    s_0 = (((s_0 + s_5) | 0) + m_9) | 0; s_15 ^= s_0; s_15 = (s_15 >>> 8) | (s_15 << 24);
    s_10 = (s_10 + s_15) | 0; s_5 ^= s_10; s_5 = (s_5 >>> 7) | (s_5 << 25);
    s_1 = (((s_1 + s_6) | 0) + m_10) | 0; s_12 ^= s_1; s_12 = (s_12 >>> 16) | (s_12 << 16);
    s_11 = (s_11 + s_12) | 0; s_6 ^= s_11; s_6 = (s_6 >>> 12) | (s_6 << 20);
    s_1 = (((s_1 + s_6) | 0) + m_11) | 0; s_12 ^= s_1; s_12 = (s_12 >>> 8) | (s_12 << 24);
    s_11 = (s_11 + s_12) | 0; s_6 ^= s_11; s_6 = (s_6 >>> 7) | (s_6 << 25);
    s_2 = (((s_2 + s_7) | 0) + m_12) | 0; s_13 ^= s_2; s_13 = (s_13 >>> 16) | (s_13 << 16);
    s_8 = (s_8 + s_13) | 0; s_7 ^= s_8; s_7 = (s_7 >>> 12) | (s_7 << 20);
    s_2 = (((s_2 + s_7) | 0) + m_13) | 0; s_13 ^= s_2; s_13 = (s_13 >>> 8) | (s_13 << 24);
    s_8 = (s_8 + s_13) | 0; s_7 ^= s_8; s_7 = (s_7 >>> 7) | (s_7 << 25);
    s_3 = (((s_3 + s_4) | 0) + m_14) | 0; s_14 ^= s_3; s_14 = (s_14 >>> 16) | (s_14 << 16);
    s_9 = (s_9 + s_14) | 0; s_4 ^= s_9; s_4 = (s_4 >>> 12) | (s_4 << 20);
    s_3 = (((s_3 + s_4) | 0) + m_15) | 0; s_14 ^= s_3; s_14 = (s_14 >>> 8) | (s_14 << 24);
    s_9 = (s_9 + s_14) | 0; s_4 ^= s_9; s_4 = (s_4 >>> 7) | (s_4 << 25);
    if (i < 6) {
      const t0 = m_0, t1 = m_1;
      m_0 = m_2; m_2 = m_3; m_3 = m_10; m_10 = m_12; m_12 = m_9; m_9 = m_11; m_11 = m_5; m_5 = t0;
      m_1 = m_6; m_6 = m_4; m_4 = m_7; m_7 = m_13; m_13 = m_14; m_14 = m_15; m_15 = m_8; m_8 = t1;
    }
  }
  return new Uint32Array([s_0 ^ s_8, s_1 ^ s_9, s_2 ^ s_10, s_3 ^ s_11, s_4 ^ s_12, s_5 ^ s_13, s_6 ^ s_14, s_7 ^ s_15]);
}

function readBlock(input, offset, length, out) {
  out.fill(0);
  const end = Math.min(offset + length, input.length);
  let wi = 0, i = offset;
  while (i + 4 <= end) {
    out[wi++] = input[i] | (input[i+1] << 8) | (input[i+2] << 16) | (input[i+3] << 24);
    i += 4;
  }
  if (i < end) {
    let word = 0, shift = 0;
    while (i < end) { word |= input[i++] << shift; shift += 8; }
    out[wi] = word;
  }
}

function readBlockFastLE(input, offset, out) {
  const absoluteOffset = input.byteOffset + offset;
  if (IS_LITTLE_ENDIAN && (absoluteOffset & 3) === 0 && offset + 64 <= input.length) {
    const view = new Uint32Array(input.buffer, absoluteOffset, 16);
    out.set(view);
    return true;
  }
  return false;
}

function cvToBytes(cv, outputLen) {
  const result = new Uint8Array(outputLen);
  for (let i = 0; i < Math.min(8, Math.ceil(outputLen / 4)); i++) {
    const word = cv[i], base = i * 4;
    if (base < outputLen) result[base] = word & 0xff;
    if (base + 1 < outputLen) result[base + 1] = (word >> 8) & 0xff;
    if (base + 2 < outputLen) result[base + 2] = (word >> 16) & 0xff;
    if (base + 3 < outputLen) result[base + 3] = (word >> 24) & 0xff;
  }
  return result;
}

function processChunk(input, chunkStart, chunkLen, chunkCounter, flags) {
  const cv = new Uint32Array(IV);
  let pos = 0;
  let blocksRemaining = Math.ceil(chunkLen / BLOCK_LEN) || 1;
  while (blocksRemaining > 0) {
    const blockLen = Math.min(BLOCK_LEN, chunkLen - pos);
    const isFirst = pos === 0;
    const isLast = blocksRemaining === 1;
    let blockFlags = flags;
    if (isFirst) blockFlags |= CHUNK_START;
    if (isLast) blockFlags |= CHUNK_END;
    if (blockLen === BLOCK_LEN && readBlockFastLE(input, chunkStart + pos, blockWordsBuffer)) {
    } else {
      readBlock(input, chunkStart + pos, blockLen, blockWordsBuffer);
    }
    const result = compress(cv, blockWordsBuffer, chunkCounter, blockLen, blockFlags);
    cv.set(result);
    pos += BLOCK_LEN;
    blocksRemaining--;
  }
  return cv;
}

function mergeParents(left, right, flags, isRoot) {
  const block = new Uint32Array(16);
  block.set(left, 0);
  block.set(right, 8);
  let parentFlags = flags | PARENT;
  if (isRoot) parentFlags |= ROOT;
  return compress(IV, block, 0, BLOCK_LEN, parentFlags);
}

// Pure JS hash
function hashJS(input, outputLen = 32) {
  const flags = 0;
  if (input.length <= CHUNK_LEN) {
    const cv = new Uint32Array(IV);
    let pos = 0;
    let blocksRemaining = Math.ceil(input.length / BLOCK_LEN) || 1;
    while (blocksRemaining > 0) {
      const blockLen = Math.min(BLOCK_LEN, input.length - pos);
      const isFirst = pos === 0;
      const isLast = blocksRemaining === 1;
      let blockFlags = flags;
      if (isFirst) blockFlags |= CHUNK_START;
      if (isLast) blockFlags |= CHUNK_END | ROOT;
      if (blockLen === BLOCK_LEN && readBlockFastLE(input, pos, blockWordsBuffer)) {
      } else {
        readBlock(input, pos, blockLen, blockWordsBuffer);
      }
      const result = compress(cv, blockWordsBuffer, 0, blockLen, blockFlags);
      cv.set(result);
      pos += BLOCK_LEN;
      blocksRemaining--;
    }
    return cvToBytes(cv, outputLen);
  }
  const numChunks = Math.ceil(input.length / CHUNK_LEN);
  const cvStack = [];
  for (let c = 0; c < numChunks; c++) {
    const chunkStart = c * CHUNK_LEN;
    const chunkLen = Math.min(CHUNK_LEN, input.length - chunkStart);
    const isLastChunk = c === numChunks - 1;
    const cv = processChunk(input, chunkStart, chunkLen, c, flags);
    cvStack.push(cv);
    if (!isLastChunk) {
      let totalChunks = c + 1;
      while ((totalChunks & 1) === 0 && cvStack.length >= 2) {
        const right = cvStack.pop();
        const left = cvStack.pop();
        cvStack.push(mergeParents(left, right, flags, false));
        totalChunks >>= 1;
      }
    }
  }
  while (cvStack.length > 1) {
    const right = cvStack.pop();
    const left = cvStack.pop();
    const isRoot = cvStack.length === 0;
    cvStack.push(mergeParents(left, right, flags, isRoot));
  }
  return cvToBytes(cvStack[0], outputLen);
}

// Check WASM SIMD support
function checkWasmSimd() {
  try {
    return WebAssembly.validate(new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7b,
      0x03, 0x02, 0x01, 0x00,
      0x0a, 0x0a, 0x01, 0x08, 0x00, 0x41, 0x00,
      0xfd, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b
    ]));
  } catch (e) {
    return false;
  }
}

// Test data generator
function generateInput(len) {
  const arr = new Uint8Array(len);
  for (let i = 0; i < len; i++) arr[i] = i % 251;
  return arr;
}

function toHex(arr) {
  return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

// Expected hashes (from official Blake3 test vectors)
const EXPECTED = {
  0: 'af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262',
  1: '2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213',
  1024: '42214739f095a406f3fc83deb889744ac00df831c10daa55189b5d121c855af7',
  1025: 'd00278ae47eb27b34faecf67b4fe263f82d5412916c1ffd97c8cb7fb814b8444',
  65536: '68d647e619a930e7a75d6c8a23d2fa5af7c11ee6bb7c21e50c54dbd6e4df8eb3',
};

const output = document.getElementById('output');

function log(msg) {
  output.textContent += msg + '\n';
}

window.runTests = function() {
  output.textContent = '';
  log('Correctness Tests');
  log('=================\n');

  let passed = 0, failed = 0;
  for (const [len, expected] of Object.entries(EXPECTED)) {
    const input = generateInput(parseInt(len));
    const got = toHex(hashJS(input));
    if (got === expected) {
      passed++;
      log(`✓ len=${len}`);
    } else {
      failed++;
      log(`✗ len=${len}`);
      log(`  got:      ${got}`);
      log(`  expected: ${expected}`);
    }
  }
  log(`\n${passed} passed, ${failed} failed`);
};

window.runBenchmark = async function() {
  output.textContent = '';
  log('Blake3 Browser Benchmark');
  log('========================\n');

  const simdSupported = checkWasmSimd();
  log(`WASM SIMD supported: ${simdSupported ? 'YES' : 'NO'}`);
  log(`Little-endian: ${IS_LITTLE_ENDIAN}`);
  log('');

  const sizes = [64, 256, 1024, 4096, 16384, 65536, 262144, 1048576];

  log('Size (bytes) | Pure JS');
  log('-------------|------------');

  for (const size of sizes) {
    const data = generateInput(size);
    const iterations = size < 10000 ? 5000 : size < 100000 ? 500 : 50;

    // Warm up
    for (let i = 0; i < 10; i++) hashJS(data);

    // Benchmark
    const start = performance.now();
    for (let i = 0; i < iterations; i++) hashJS(data);
    const elapsed = performance.now() - start;

    const throughput = (size * iterations) / (elapsed / 1000) / (1024 * 1024);
    log(`${size.toString().padStart(12)} | ${throughput.toFixed(1).padStart(8)} MB/s`);

    // Yield to UI
    await new Promise(r => setTimeout(r, 0));
  }

  log('\nNote: WASM SIMD compress4x would add ~1.4x speedup');
  log('Workers would help for very large inputs (>1MB)');
};
</script>
</body>
</html>
